//===----------------------------------------------------------------------===//
//
// This source file is part of the SwiftOpenAPIGenerator open source project
//
// Copyright (c) 2023 Apple Inc. and the SwiftOpenAPIGenerator project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of SwiftOpenAPIGenerator project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
import OpenAPIRuntime
import Foundation
#if canImport(FoundationNetworking)
@preconcurrency import FoundationNetworking
#endif

/// A client transport that performs HTTP operations using the URLSession type
/// provided by the Foundation framework.
///
/// ### Use the URLSession transport
///
/// Instantiate the transport:
///
///     let transport = URLSessionTransport()
///
/// Create the base URL of the server to call using your client. If the server
/// URL was defined in the OpenAPI document, you find a generated method for it
/// on the `Servers` type, for example:
///
///     let serverURL = try Servers.server1()
///
/// Instantiate the `Client` type generated by the Swift OpenAPI Generator for
/// your provided OpenAPI document. For example:
///
///     let client = Client(
///         serverURL: serverURL,
///         transport: transport
///     )
///
/// Use the client to make HTTP calls defined in your OpenAPI document. For
/// example, if the OpenAPI document contains an HTTP operation with
/// the identifier `checkHealth`, call it from Swift with:
///
///     let response = try await client.checkHealth(.init())
///     // ...
///
/// ### Provide a custom URLSession
///
/// The ``URLSessionTransport/Configuration-swift.struct`` type allows you to
/// provide a custom URLSession and tweak behaviors such as the default
/// timeouts, authentication challenges, and more.
public struct URLSessionTransport: ClientTransport {

    /// A set of configuration values for the URLSession transport.
    public struct Configuration: Sendable {

        /// The URLSession used for performing HTTP operations.
        public var session: URLSession

        /// Creates a new configuration with the provided session.
        /// - Parameters:
        ///     - session: The URLSession used for performing HTTP operations.
        ///     If none is provided, the system uses the shared URLSession.
        public init(session: URLSession = .shared) {
            self.session = session
        }
    }

    /// A set of configuration values used by the transport.
    public var configuration: Configuration

    /// Creates a new URLSession-based transport.
    /// - Parameters:
    ///   - configuration: A set of configuration values used by the transport.
    public init(configuration: Configuration = .init()) {
        self.configuration = configuration
    }

    public func send(
        _ request: OpenAPIRuntime.Request,
        baseURL: URL,
        operationID: String
    ) async throws -> OpenAPIRuntime.Response {
        let urlRequest = try URLRequest(request, baseURL: baseURL)
        let (responseBody, urlResponse) = try await invokeSession(urlRequest)
        return try OpenAPIRuntime.Response(from: urlResponse, body: responseBody)
    }

    private func invokeSession(_ urlRequest: URLRequest) async throws -> (Data, URLResponse) {
        // Using `dataTask(with:completionHandler:)` instead of the async method `data(for:)` of URLSession because the latter is not available on linux platforms
        return try await withCheckedThrowingContinuation { continuation in
            configuration.session
                .dataTask(with: urlRequest) { data, response, error in
                    if let error {
                        continuation.resume(with: .failure(error))
                        return
                    }

                    guard let response else {
                        continuation.resume(
                            with: .failure(URLSessionTransportError.noResponse(url: urlRequest.url))
                        )
                        return
                    }

                    continuation.resume(
                        with: .success((data ?? Data(), response))
                    )
                }
                .resume()
        }
    }
}

/// Specialized error thrown by the transport.
internal enum URLSessionTransportError: Error {

    /// Invalid URL composed from base URL and received request.
    case invalidRequestURL(request: OpenAPIRuntime.Request, baseURL: URL)

    /// Returned `URLResponse` could not be converted to `HTTPURLResponse`.
    case notHTTPResponse(URLResponse)

    /// Returned `URLResponse` was nil
    case noResponse(url: URL?)
}

extension OpenAPIRuntime.Response {
    init(from urlResponse: URLResponse, body: Data) throws {
        guard let httpResponse = urlResponse as? HTTPURLResponse else {
            throw URLSessionTransportError.notHTTPResponse(urlResponse)
        }
        let headerFields: [HeaderField] = httpResponse
            .allHeaderFields
            .compactMap { headerName, headerValue in
                guard let name = headerName as? String, let value = headerValue as? String else {
                    return nil
                }
                return HeaderField(name: name, value: value)
            }
        self.init(statusCode: httpResponse.statusCode, headerFields: headerFields, body: body)
    }
}

extension URLRequest {
    init(_ request: OpenAPIRuntime.Request, baseURL: URL) throws {
        guard var baseUrlComponents = URLComponents(string: baseURL.absoluteString) else {
            throw URLSessionTransportError.invalidRequestURL(request: request, baseURL: baseURL)
        }
        baseUrlComponents.path += request.path
        baseUrlComponents.percentEncodedQuery = request.query
        guard let url = baseUrlComponents.url else {
            throw URLSessionTransportError.invalidRequestURL(request: request, baseURL: baseURL)
        }
        self.init(url: url)
        self.httpMethod = request.method.name
        for header in request.headerFields {
            self.addValue(header.value, forHTTPHeaderField: header.name)
        }
        if let body = request.body {
            self.httpBody = body
        }
    }
}

extension URLSessionTransportError: LocalizedError {
    public var errorDescription: String? { description }
}

extension URLSessionTransportError: CustomStringConvertible {
    public var description: String {
        switch self {
        case let .invalidRequestURL(request: request, baseURL: baseURL):
            return
                "Invalid request URL from request path: \(request.path), query: \(request.query ?? "<nil>") relative to base URL: \(baseURL.absoluteString)"
        case .notHTTPResponse(let response):
            return "Received a non-HTTP response, of type: \(String(describing: type(of: response)))"
        case .noResponse(let url):
            return "Received a nil response for \(url?.absoluteString ?? "<nil URL>")"
        }
    }
}
